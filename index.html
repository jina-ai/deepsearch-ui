<!DOCTYPE html>
<html>

<head>
  <title>Jina DeepSearch Chat</title>
  <meta charset="utf-8">
  <meta name="title" content="DeepSearch Chat">
  <meta name="description" content="Search, read and reason until best answer found.">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://search.jina.ait">
  <meta property="og:title" content="DeepSearch Chat">
  <meta property="og:description" content="Search, read and reason until best answer found.">
  <meta property="og:image" content="https://jina.ai/banner-deepsearch.png">
  <meta property="twitter:site" content="@JinaAI_">
  <meta name="twitter:creator" content="@JinaAI_">
  <meta property="twitter:card" content="summary_large_image">
  <meta property="twitter:url" content="https://search.jina.ai">
  <meta property="twitter:title" content="DeepSearch Chat">
  <meta property="twitter:description" content="Search, read and reason until best answer found.">
  <meta property="twitter:image" content="https://jina.ai/banner-deepsearch.png">
  <style>
    :root {
      --bg-color: #121212;
      --text-color: #fff;
      --message-bg: #323838;
      --input-bg: #323838;
      --button-primary-bg: #81e3ee;
      --button-primary-text: #000;
      --button-secondary-bg: #484e4e;
      --button-secondary-text: #fff;
      --button-disabled-bg: #ccc;
      --code-bg: #484e4e;
      --link-color: #81e3ee;
      --text-error-color: #FB767B;
      --border-color: #323838;
    }

    [data-theme="light"] {
      --bg-color: #ffffff;
      --text-color: #000000;
      --message-bg: #f0f0f0;
      --input-bg: #ffffff;
      --input-border: #cccccc;
      --button-primary-bg: #81e3ee;
      --button-primary-text: #000;
      --button-secondary-bg: #484e4e;
      --button-secondary-text: #fff;
      --button-disabled-bg: #ccc;
      --code-bg: #f5f5f5;
      --api-input-bg: #ffffff;
      --link-color: #81e3ee;
      --text-error-color: #FB767B;
      --border-color: #ccc;
    }

    body {
      font-family: sans-serif;
      margin: 0;
      /* Remove body margin */
      height: 100vh;
      /* Ensure body takes up the full viewport height */
      overflow: hidden;
      background-color: var(--bg-color);
      color: var(--text-color);
      /* Prevent body scroll */
    }

    #chat-app {
      position: relative;
      height: 100%;
      /* Occupy full body height */
      padding: 0 20px;
      display: flex;
      flex-direction: column;
    }

    #chat-container {
      width: 100%;
      padding: 10px;
      margin-bottom: 60px;
      /* Give space for input area */
      overflow-y: auto;
      /* Enable vertical scroll */
      flex-grow: 1;
      /* Take up available space */
    }

    .message {
      margin-bottom: 5px;
      padding: 20px;
      margin-top: 20px;
      margin-bottom: 20px;
      border-radius: 5px;
      width: fit-content;
      max-width: 80%;
      /* Prevent messages from becoming too wide */
      word-break: break-word;
      background-color: var(--message-bg);
      color: var(--text-color);
      /* Handle long words */
    }

    .user-message {
      /* background-color: #DCF8C6; */
      text-align: right;
      align-self: flex-end;
      /* Align to the right in the chat container */
    }

    .assistant-message {
      /* background-color: #ECE5DD; */
      text-align: left;
      align-self: flex-start;
      /* Align to the left in the chat container */
    }

    #input-area {
      display: flex;
      position: absolute;
      bottom: 20px;
      left: 20px;
      right: 20px;
      /* Align with chat app padding */
    }

    #message-input {
      flex-grow: 1;
      padding: 8px;
      border: 1px solid var(--input-border);
      border-radius: 5px;
      background-color: var(--input-bg);
      color: var(--text-color);
      height: 32px;
    }

    #send-button {
      padding: 8px 15px;
      background-color: var( --button-primary-bg);
      margin-left: 8px;
      color: var(--button-primary-text);
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }

    #send-button:disabled {
      background-color: var(--button-disabled-bg);
      cursor: not-allowed;
    }

    #clear-button {
      padding: 8px 15px;
      background-color: var(--text-error-color);
      /* Red color */
      color: var(--button-primary-text);
      border: none;
      border-radius: 5px;
      cursor: pointer;
      margin-left: 8px;
    }

    #error-message {
      color: var(--text-error-color);
      margin-top: 5px;
      display: none;
    }

    /* Styles for the think section */
    .think-section {
      /* border: 1px solid #ccc; */
      margin-top: 5px;
      padding: 5px;
      border-radius: 3px;
    }

    .think-header {
      cursor: pointer;
      font-weight: bold;
      margin-bottom: 5px;
    }

    .think-content {
      display: none;
      /* Initially hidden */
      color: #929595;
      padding: 5px;
      font-family: monospace;
      line-height: 1.25;
    }

    /* Basic Markdown Styling */
    .markdown p {
      margin-bottom: 0.5em;
    }

    .markdown h1 {
      font-size: 1.5em;
      margin-bottom: 0.75em;
      border-bottom: 1px solid var(--border-color);
    }

    .markdown h2 {
      font-size: 1.2em;
      margin-bottom: 0.6em;
    }

    .markdown pre code {
      padding: 0.75em;
    }

    .markdown ul,
    .markdown ol {
      padding-left: 20px;
      margin-bottom: 0.5em;
    }

    .markdown a {
      color: var(--link-color);
    }

    .markdown code {
      white-space: pre-line;
      font-size: 14px;
      display: inline-block;
      padding: 2px 4px;
      background-color: var(--code-bg);
      border-radius: 3px;
      font-family: monospace;
    }

    .markdown table {
      display: block;
      width: 100%;
      transform: translateZ(0);
      overflow: auto;
      border-collapse: collapse;
      margin: 1em 0;
    }

    .markdown #footnote-label {
      display: none;
    }

    /* Add flexbox to chat container */
    #chat-container {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      /* Align items to the start horizontally */
    }
    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 0;
    }

    #logo {
      height: 32px;
    }

    .header-buttons {
      display: flex;
      gap: 10px;
    }

    .header-button {
      padding: 8px 15px;
      border-radius: 4px;
      border: none;
      cursor: pointer;
    }

    .header-button:disabled {
      background-color: var(--button-disabled-bg);
      cursor: not-allowed;
    }

    .get-key-btn {
      background: var(--button-secondary-bg);
      color: var(--button-secondary-text);
      text-decoration: none;
    }

    .add-key-btn, save-api-key {
      background: var(--button-primary-bg);
      color: var(--button-primary-text);
    }

    #api-key-input {
      padding: 8px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      background: var(--input-bg);
      color: var(--text-color);
      width: 300px;
    }

    #theme-toggle {
      padding: 8px 15px;
      background-color: var(--button-secondary-bg);
      color: var(--button-secondary-text);
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    /* Add these new styles for the dialog */
    .dialog-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      z-index: 100;
      align-items: center;
      justify-content: center;
    }

    .dialog {
      background: var(--bg-color);
      padding: 20px;
      border-radius: 8px;
      min-width: 300px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }

    .dialog-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }

    .dialog-title {
      font-size: 1.2em;
      font-weight: bold;
      color: var(--text-color);
    }

    .dialog-close {
      background: none;
      border: none;
      font-size: 1.5em;
      cursor: pointer;
      color: var(--text-color);
      padding: 0;
    }

    .dialog-content {
      margin-bottom: 20px;
    }

    .dialog-footer {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
    }
    
    .error-message button {
      padding: 8px 15px;
      border-radius: 4px;
      border: none;
      cursor: pointer;
      margin-top: 20px;
      background-color: var(--button-primary-bg);
      color: var(--button-primary-text);
      display: block;
    }
  </style>
  <script defer src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/marked-footnote/dist/index.umd.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/marked-highlight/lib/index.umd.js"></script>

  <link defer rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/vs2015.min.css">
  <script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
</head>

<body>
  <div id="chat-app">
    <header>
      <img id="logo" src="Jina - Dark.svg">
      <div class="header-buttons">
        <button id="toggle-api-key" class="header-button add-key-btn">Add API Key</button>
        <a href="https://jina.ai" target="_blank">
          <button class="header-button get-key-btn">Get API Key</button>
        </a>
        <button id="theme-toggle" class="header-button">Toggle Theme</button>
      </div>
    </header>
    <div id="chat-container">
      <!-- Chat messages will be displayed here -->
    </div>

    <div id="input-area">
      <input type="text" id="message-input" placeholder="Type your message..." />
      <button id="send-button">Send</button>
      <button id="clear-button">Clear</button>
    </div>

    <div id="error-message"></div>
  </div>

  <!-- Add the dialog HTML -->
  <div class="dialog-overlay" id="api-key-dialog">
    <div class="dialog">
      <div class="dialog-header">
        <span class="dialog-title">Add API Key</span>
        <button class="dialog-close">&times;</button>
      </div>
      <div class="dialog-content">
        <input type="password" id="api-key-input" placeholder="Enter your API key">
      </div>
      <div class="dialog-footer">
        <button id="save-api-key" class="header-button add-key-btn">Save</button>
      </div>
    </div>
  </div>

  <script defer>
    // Add this at the beginning of your script section
    const themeToggle = document.getElementById('theme-toggle');
    const logo = document.getElementById('logo');
    
    // Function to update logo based on theme
    function updateLogo(theme) {
      logo.src = theme === 'dark' ? 'Jina - Dark.svg' : 'Jina - Light.svg';
    }
    
    // Check for saved theme preference or default to 'dark'
    const savedTheme = localStorage.getItem('theme') || 'dark';
    document.documentElement.setAttribute('data-theme', savedTheme);
    themeToggle.textContent = `${savedTheme === 'dark' ? 'Light' : 'Dark'} Mode`;
    updateLogo(savedTheme); // Set initial logo

    // Theme toggle handler
    themeToggle.addEventListener('click', () => {
      const currentTheme = document.documentElement.getAttribute('data-theme');
      const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
      
      document.documentElement.setAttribute('data-theme', newTheme);
      localStorage.setItem('theme', newTheme);
      themeToggle.textContent = `${newTheme === 'dark' ? 'Light' : 'Dark'} Mode`;
      updateLogo(newTheme); // Update logo when theme changes
    });

    const chatContainer = document.getElementById('chat-container');
    const messageInput = document.getElementById('message-input');
    const sendButton = document.getElementById('send-button');
    const clearButton = document.getElementById('clear-button');
    const errorMessage = document.getElementById('error-message');

    const apiKeyInput = document.getElementById('api-key-input');
    const saveApiKeyBtn = document.getElementById('save-api-key');
    const toggleApiKeyBtn = document.getElementById('toggle-api-key');

    const BASE_ORIGIN = 'https://deepsearch.jina.ai';
    let isLoading = false;
    let abortController = null;
    let existingMessages = []; // Array to store existing messages

    // Update the API key dialog logic
    const apiKeyDialog = document.getElementById('api-key-dialog');
    const dialogCloseBtn = document.querySelector('.dialog-close');
    
    toggleApiKeyBtn.addEventListener('click', () => {
      apiKeyDialog.style.display = 'flex';
    });

    dialogCloseBtn.addEventListener('click', () => {
      apiKeyDialog.style.display = 'none';
    });

    // Close dialog when clicking outside
    apiKeyDialog.addEventListener('click', (e) => {
      if (e.target === apiKeyDialog) {
        apiKeyDialog.style.display = 'none';
      }
    });

    // Load saved API key
    apiKeyInput.value = localStorage.getItem('api_key') || '';
    saveApiKeyBtn.disabled = !apiKeyInput.value.trim();
    apiKeyInput.addEventListener('input', () => {
      saveApiKeyBtn.disabled = !apiKeyInput.value.trim();
    });

    saveApiKeyBtn.addEventListener('click', () => {
      const key = apiKeyInput.value.trim();
      if (key) {
        localStorage.setItem('api_key', key);
        apiKeyDialog.style.display = 'none';
      }
    });

    sendButton.addEventListener('click', sendMessage);
    clearButton.addEventListener('click', clearMessages); // Add clear button event listener
    messageInput.addEventListener('keydown', (event) => {
      if (event.key === "Enter") {
        sendMessage();
      }
    });

    function clearMessages() {
      chatContainer.innerHTML = ''; // Clear the chat container
      existingMessages = []; // Clear the existing messages array
      abortController?.abort(); // Abort any ongoing requests
    }

    async function sendMessage() {
      const query = messageInput.value.trim();

      if (!query) return; // Don't send empty messages
      if (isLoading) return;

      errorMessage.textContent = ''; // Clear any previous errors
      abortController = new AbortController();
      isLoading = true;
      sendButton.disabled = true;
      let loadingIndicatorRemoved = false;


      displayMessage('user', query);
      existingMessages.push({ role: 'user', content: query }); // Add user message to existing messages
      messageInput.value = ''; // Clear the input

      const assistantMessageDiv = displayMessage('assistant', ''); // Create the main assistant message div
      const markdownDiv = document.createElement('div'); // create markdown div here
      markdownDiv.classList.add('markdown');
      assistantMessageDiv.appendChild(markdownDiv);

      let markdownContent = '';
      let thinkContent = '';
      let inThinkSection = false;
      let thinkSectionElement = null; // Store the think section element
      let thinkHeaderElement = null; // Store the think header element

      function renderMarkdown(text) {
        const { Marked } = globalThis.marked;
        const { markedHighlight } = globalThis.markedHighlight;
        const marked = new Marked(markedHighlight({
          emptyLangClass: 'hljs',
          langPrefix: 'hljs language-',
          highlight(code, lang, info) {
            const language = hljs.getLanguage(lang) ? lang : 'plaintext';
            return hljs.highlight(code, { language }).value;
          }
        })).use(markedFootnote());
        // Use marked.parse to convert Markdown to HTML
        const html = marked.parse(text);

        return html;
      }

      try {
        const payload = {
          messages: existingMessages,
          stream: true,
        };

        const headers = {
          'Content-Type': 'application/json',
        }
        if (localStorage.getItem('api_key')) {
          headers['Authorization'] = `Bearer ${localStorage.getItem('api_key')}`;
        }

        const res = await fetch(`${BASE_ORIGIN}/v1/chat/completions`, {
          method: 'POST',
          headers: headers,
          body: JSON.stringify(payload),
          signal: abortController.signal,
        });

        if (!res.ok) {
          const errorResponse = await res.json().catch(() => ({}));
          const errorMsg = errorResponse.message || 'Unknown error occurred';
          
          // Remove the loading message
          assistantMessageDiv.remove();
          
          // Handle specific error status codes
          switch (res.status) {
            case 401:
              showErrorWithAction(
                'Invalid API key', 
                'Update API Key', 
                () => apiKeyDialog.style.display = 'flex'
              );
              break;
            case 402:
              showErrorWithAction(
                'Insufficient tokens', 
                'Purchase More Tokens', 
                () => window.open('https://jina.ai/api-dashboard/key-manager', '_blank')
              );
              break;
            case 429:
              showErrorWithAction(
                'Rate limit exceeded', 
                'Add API Key', 
                () => apiKeyDialog.style.display = 'flex'
              );
              break;
            default:
              // Show generic error as a message
              const errorMessageDiv = document.createElement('div');
              errorMessageDiv.classList.add('message', 'assistant-message');
              errorMessageDiv.textContent = `Error: ${errorMsg}`;
              chatContainer.appendChild(errorMessageDiv);
          }
          
          throw new Error(errorMsg);
        }

        if (res.headers.get('content-type')?.includes('text/event-stream')) {
          if (res.body) {
            const reader = res.body.getReader();
            const decoder = new TextDecoder();
            let partialBrokenData = '';

            while (true) {
              const { done, value } = await reader.read();

              if (done) {
                isLoading = false;
                sendButton.disabled = false;
                break;
              }

              if (value) {
                const streamData = decoder.decode(value);
                const events = streamData.split('\n\ndata:').filter(Boolean);

                events.forEach(event => {
                  const data = event.replace(/data: /, '').trim();

                  partialBrokenData += data;
                  try {
                    if (partialBrokenData) {
                      const json = JSON.parse(partialBrokenData);
                      partialBrokenData = '';
                      const content = json.choices[0].delta.content;
                      removeLoadingIndicator(assistantMessageDiv);

                      let tempContent = content;
                      while (tempContent.length > 0) {
                        if (inThinkSection) {
                          const thinkEndIndex = tempContent.indexOf("</think>");
                          if (thinkEndIndex !== -1) {
                            thinkContent += tempContent.substring(0, thinkEndIndex);
                            if (thinkSectionElement) {
                              thinkSectionElement.querySelector('.think-content').textContent = thinkContent;
                            }
                            inThinkSection = false;
                            tempContent = tempContent.substring(thinkEndIndex + "</think>".length);
                            if (thinkSectionElement) {
                              const thinkContentElement = thinkSectionElement.querySelector('.think-content');
                              thinkContentElement.style.display = 'none'; // Collapse
                              // Change header text to "Chain of thoughts"
                              if (thinkHeaderElement) {
                                thinkHeaderElement.textContent = 'Chain of thoughts (Click to toggle)';
                              }
                            }
                          } else {
                            thinkContent += tempContent;
                            if (thinkSectionElement) {
                              thinkSectionElement.querySelector('.think-content').textContent = thinkContent;
                              thinkSectionElement.querySelector('.think-content').style.display = 'block'; // Ensure it's visible while streaming
                            }
                            tempContent = "";
                          }
                        } else {
                          const thinkStartIndex = tempContent.indexOf("<think>");
                          if (thinkStartIndex !== -1) {
                            // Process markdown content before <think>
                            markdownContent += tempContent.substring(0, thinkStartIndex);
                            const markdownHTML = renderMarkdown(markdownContent);
                            markdownDiv.innerHTML = markdownHTML; // Update the markdown section

                            // Create and expand think section
                            inThinkSection = true;
                            thinkContent = "";
                            tempContent = tempContent.substring(thinkStartIndex + "<think>".length);
                            thinkSectionElement = createThinkSection(assistantMessageDiv); //Create think section.
                            thinkHeaderElement = thinkSectionElement.querySelector('.think-header'); // Get the header element
                            thinkSectionElement.querySelector('.think-content').textContent = thinkContent;
                            const thinkContentElement = thinkSectionElement.querySelector('.think-content');
                            thinkContentElement.style.display = 'block'; // Expand the think section when created
                            //change header text
                            if (thinkHeaderElement) {
                              thinkHeaderElement.textContent = 'Thinking... (Click to toggle)';
                            }

                          } else {
                            // Append to markdown content
                            markdownContent += tempContent;
                            const markdownHTML = renderMarkdown(markdownContent);
                            markdownDiv.innerHTML = markdownHTML; // Update the markdown section
                            tempContent = "";
                          }
                        }
                      }
                    }
                  } catch (e) {
                    console.error('Error parsing full JSON:', e);
                  }
                });
              }
            }

            // If there's remaining markdown content after streaming, render it
            if (markdownContent) {
              const markdownHTML = renderMarkdown(markdownContent);
              markdownDiv.innerHTML = markdownHTML;
            }

          }
        } else {
          const jsonResult = await res.json();
          if (jsonResult) {
            assistantMessageDiv.textContent = jsonResult.choices[0].message.content;
          } else {
            throw new Error('Empty response from server.');
          }
        }
		 let assistantContent = assistantMessageDiv.textContent;
		 existingMessages.push({role: 'assistant', content: assistantContent});

      } catch (error) {
        if (error.name !== 'AbortError') {
          let errorMsg = error instanceof Error ? error.message : String(error);
          if (!document.querySelector('.error-container')) {
            errorMessage.textContent = `Error: ${errorMsg}`;
          }
        } else {
          // Handle abort error (optional)
          if (assistantMessageDiv) {
            assistantMessageDiv.textContent = "Request cancelled.";
          }
        }
      } finally {
        isLoading = false;
        sendButton.disabled = false;
      }
    }

    // Add this new function to handle errors with actions
    function showErrorWithAction(message, buttonText, onClick) {
      const messageDiv = document.createElement('div');
      messageDiv.classList.add('message', 'assistant-message');
      
      const errorContainer = document.createElement('div');
      errorContainer.className = 'error-message';
      
      const errorText = document.createElement('span');
      errorText.textContent = message;
      
      const actionButton = document.createElement('button');
      actionButton.textContent = buttonText;
      actionButton.addEventListener('click', onClick);
      
      errorContainer.appendChild(errorText);
      errorContainer.appendChild(actionButton);
      messageDiv.appendChild(errorContainer);
      chatContainer.appendChild(messageDiv);
      
      scrollToBottom();
    }

    function displayMessage(role, content) {
      const messageDiv = document.createElement('div');
      messageDiv.classList.add('message');
      messageDiv.classList.add(`${role}-message`);
      messageDiv.textContent = content; // Set the text content here

      if (role === 'assistant') {
        messageDiv.innerHTML = '<div class="loading-indicator">Loading...</div>'; // Initial loading indicator
      } else {
        messageDiv.textContent = content;
      }

      chatContainer.appendChild(messageDiv);
      // Apply text direction based on role for proper alignment
      if (role === 'user') {
        messageDiv.style.textAlign = 'right';
      } else {
        messageDiv.style.textAlign = 'left';
      }

      chatContainer.scrollTop = chatContainer.scrollHeight; // Scroll to bottom
      return messageDiv; // Return the element for updating content later
    }

    function createThinkSection(messageDiv) {
      const thinkSection = document.createElement('div');
      thinkSection.classList.add('think-section');

      const thinkHeader = document.createElement('div');
      thinkHeader.classList.add('think-header');
      thinkHeader.textContent = 'Thinking... (Click to toggle)';
      thinkSection.appendChild(thinkHeader);

      const thinkContent = document.createElement('div');
      thinkContent.classList.add('think-content');
      thinkSection.appendChild(thinkContent);

      thinkHeader.addEventListener('click', () => {
        thinkHeader.classList.toggle('expanded');
        thinkContent.style.display = thinkContent.style.display === 'none' ? 'block' : 'none';
      });

      messageDiv.prepend(thinkSection);
      return thinkSection; // Return the created element
    }

    // Function to scroll to the bottom of the chat container
    function scrollToBottom() {
      chatContainer.scrollTop = chatContainer.scrollHeight;
    }

    // Call scrollToBottom after each message is displayed
    const originalDisplayMessage = displayMessage; // Store the original function

    displayMessage = function (role, content) { // Override the function
      const messageDiv = originalDisplayMessage(role, content); // Call the original
      scrollToBottom(); // Scroll to bottom after displaying message
      return messageDiv;
    };

    // Scroll to the bottom initially
    scrollToBottom();

    //add the removeLoadingIndicator method.
    function removeLoadingIndicator(messageDiv) {
      const loadingIndicator = messageDiv.querySelector('.loading-indicator');
      if (loadingIndicator) {
        loadingIndicator.remove();
      }
    }


    const observer = new MutationObserver(function (mutations) {
      mutations.forEach(function (mutation) {
        if (mutation.type === 'childList') {
          scrollToBottom(); // Scroll when new nodes are added
        }
      });
    });

    // Configuration for the observer
    const config = { childList: true, subtree: true };

    // Start observing the chat container
    observer.observe(chatContainer, config);
  </script>
</body>

</html>